[problem]
id = "union-types-01"
title = "Union型の基礎"
description = """
TypeScriptのUnion型を使って、複数の型を扱う方法を学びましょう。

目標:
- Union型の定義と使用方法
- Type Guardsによる型の絞り込み
- Discriminated Unionsの実装
"""
difficulty = "medium"
category = "unions"
initialCode = """
// 1. 基本的なUnion型を定義してください
// 文字列または数値を受け取る
function processValue(value) {
  // 型に応じて処理を分岐
  if (/* 型チェック */) {
    return value.toUpperCase();
  } else {
    return value * 2;
  }
}

// 2. Discriminated Unionを定義してください
// 成功/エラー/ローディング状態を表現
type Result = any;

function handleResult(result: Result) {
  // 状態に応じて処理
}

// 3. 配列またはオブジェクトを処理する関数
function processData(data) {
  // 配列なら長さ、オブジェクトならキーの数を返す
}
"""
solution = """
// 1. 基本的なUnion型を定義してください
// 文字列または数値を受け取る
function processValue(value: string | number): string | number {
  // 型に応じて処理を分岐
  if (typeof value === 'string') {
    return value.toUpperCase();
  } else {
    return value * 2;
  }
}

// 2. Discriminated Unionを定義してください
// 成功/エラー/ローディング状態を表現
type Result = 
  | { status: 'success'; data: string }
  | { status: 'error'; error: string }
  | { status: 'loading' };

function handleResult(result: Result): void {
  // 状態に応じて処理
  switch (result.status) {
    case 'success':
      console.log('Data:', result.data);
      break;
    case 'error':
      console.error('Error:', result.error);
      break;
    case 'loading':
      console.log('Loading...');
      break;
  }
}

// 3. 配列またはオブジェクトを処理する関数
function processData<T>(data: T[] | Record<string, T>): number {
  // 配列なら長さ、オブジェクトならキーの数を返す
  if (Array.isArray(data)) {
    return data.length;
  } else {
    return Object.keys(data).length;
  }
}
"""
hints = [
  "Union型は | を使って複数の型を組み合わせます",
  "typeof演算子で基本的な型を判定できます",
  "Discriminated Unionは共通のプロパティで型を識別します"
]
tags = ["union", "types", "guards", "discriminated"]
# AST-based Type Assertions
[[typeAssertions]]
symbol = "processValue"
symbolKind = "function"
mode = "structural"
description = "Union型を受け取り処理する関数"

[typeAssertions.pattern]
kind = "function"

[[typeAssertions.pattern.parameters]]
name = "value"
[typeAssertions.pattern.parameters.type]
kind = "union"
[[typeAssertions.pattern.parameters.type.types]]
kind = "primitive"
type = "string"
[[typeAssertions.pattern.parameters.type.types]]
kind = "primitive"
type = "number"

[typeAssertions.pattern.returnType]
kind = "union"
[[typeAssertions.pattern.returnType.types]]
kind = "primitive"
type = "string"
[[typeAssertions.pattern.returnType.types]]
kind = "primitive"
type = "number"

# ----------------------------------------------------------------------------

[[typeAssertions]]
symbol = "Result"
symbolKind = "type"
mode = "structural"
description = "Discriminated Union型の定義"

[typeAssertions.pattern]
kind = "union"
discriminator = "status"

[[typeAssertions.pattern.types]]
kind = "object"
[[typeAssertions.pattern.types.properties]]
name = "status"
[typeAssertions.pattern.types.properties.type]
kind = "literal"
value = "success"
[[typeAssertions.pattern.types.properties]]
name = "data"
[typeAssertions.pattern.types.properties.type]
kind = "primitive"
type = "string"

[[typeAssertions.pattern.types]]
kind = "object"
[[typeAssertions.pattern.types.properties]]
name = "status"
[typeAssertions.pattern.types.properties.type]
kind = "literal"
value = "error"
[[typeAssertions.pattern.types.properties]]
name = "error"
[typeAssertions.pattern.types.properties.type]
kind = "primitive"
type = "string"

[[typeAssertions.pattern.types]]
kind = "object"
[[typeAssertions.pattern.types.properties]]
name = "status"
[typeAssertions.pattern.types.properties.type]
kind = "literal"
value = "loading"

# ----------------------------------------------------------------------------

[[typeAssertions]]
symbol = "handleResult"
symbolKind = "function"
mode = "structural"
description = "Result型を処理する関数"

[typeAssertions.pattern]
kind = "function"

[[typeAssertions.pattern.parameters]]
name = "result"
[typeAssertions.pattern.parameters.type]
kind = "generic"
typeName = "Result"

[typeAssertions.pattern.returnType]
kind = "primitive"
type = "void"

# ----------------------------------------------------------------------------

[[typeAssertions]]
symbol = "processData"
symbolKind = "function"
mode = "structural"
description = "配列またはオブジェクトを処理する関数"

[typeAssertions.pattern]
kind = "function"

[[typeAssertions.pattern.typeParameters]]
name = "T"

[[typeAssertions.pattern.parameters]]
name = "data"
[typeAssertions.pattern.parameters.type]
kind = "union"

[[typeAssertions.pattern.parameters.type.types]]
kind = "array"
[typeAssertions.pattern.parameters.type.types.elementType]
kind = "typeReference"
name = "T"

[[typeAssertions.pattern.parameters.type.types]]
kind = "generic"
typeName = "Record"
[[typeAssertions.pattern.parameters.type.types.typeArguments]]
kind = "primitive"
type = "string"
[[typeAssertions.pattern.parameters.type.types.typeArguments]]
kind = "typeReference"
name = "T"

[typeAssertions.pattern.returnType]
kind = "primitive"
type = "number"